<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Tetris Pixel Art – Play Classic Tetris Online (PWA, Offline)</title>
<link rel="canonical" href="https://example.com/" />
<meta name="description" content="Play a fast, mobile-first Tetris Pixel Art game. Classic 10x20 grid, 7 tetrominoes, high scores with LocalStorage, PWA offline support, neon dark theme, 60 FPS." />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:title" content="Tetris Pixel Art – Classic Tetris (PWA)" />
<meta property="og:description" content="Classic Tetris with pixel art, mobile controls, high scores, PWA offline support, neon dark theme." />
<meta property="og:url" content="https://example.com/" />
<meta property="og:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAABCElEQVR4nGNgYGBgYGBQAAH/AQABBgABAwABAAADiQH2gAAAAABJRU5ErkJggg==" />

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Tetris Pixel Art – Classic Tetris (PWA)" />
<meta name="twitter:description" content="Play Tetris in a neon dark theme with pixel art. Mobile-first, offline PWA, LocalStorage high scores." />
<meta name="twitter:image" content="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAABCElEQVR4nGNgYGBgYGBQAAH/AQABBgABAwABAAADiQH2gAAAAABJRU5ErkJggg==" />

<link rel="manifest" href="manifest.json" />
<meta name="theme-color" content="#0b0f17" />

<style>
/* ===== Minimal precompiled Tailwind utilities used in this page (no external deps) ===== */
:root{--bg:#0b0f17;--fg:#d9f7ff;--muted:#8ab9c6;--accent:#00e5ff;--accent2:#a855f7;--glass:rgba(255,255,255,.08);--glass-br:rgba(255,255,255,.18)}
*{box-sizing:border-box}
html,body{height:100%;scroll-behavior:smooth}
body{margin:0;background:radial-gradient(1200px 600px at 50% -10%,#0f172a,#0b0f17 60%,#06080f);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
a{color:var(--accent);text-decoration:none}
.container{max-width:1100px;margin:0 auto;padding:0 16px}
.flex{display:flex}.items-center{align-items:center}.justify-between{justify-content:space-between}
.grid{display:grid}.gap-2{gap:.5rem}.gap-3{gap:.75rem}
.p-2{padding:.5rem}.p-3{padding:.75rem}.p-4{padding:1rem}.px-3{padding-left:.75rem;padding-right:.75rem}
.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-3{padding-top:.75rem;padding-bottom:.75rem}
.rounded-xl{border-radius:1rem}.rounded-2xl{border-radius:1.25rem}
.shadow-lg{box-shadow:0 8px 30px rgba(0,0,0,.45)}
.text-xs{font-size:.75rem}.text-sm{font-size:.875rem}.text-base{font-size:1rem}.text-lg{font-size:1.125rem}
.text-2xl{font-size:1.5rem}.text-3xl{font-size:1.875rem}.font-bold{font-weight:700}.font-semibold{font-weight:600}
.uppercase{text-transform:uppercase}.opacity-70{opacity:.7}.opacity-80{opacity:.8}
.btn{min-width:44px;min-height:44px;display:inline-flex;align-items:center;justify-content:center;border:1px solid transparent;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);border-radius:14px;color:var(--fg);padding:.6rem .9rem}
.btn:active{transform:scale(.98)}
.neon{color:var(--accent);text-shadow:0 0 14px rgba(0,229,255,.6)}
.glass{background:var(--glass);border:1px solid var(--glass-br);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px)}
.badge{border:1px solid var(--glass-br);padding:.25rem .5rem;border-radius:999px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03))}
hr{border:0;height:1px;background:linear-gradient(90deg,transparent,rgba(255,255,255,.15),transparent);margin:24px 0}

/* ===== Game layout ===== */
#view{position:relative;width:100vw;height:100vh;overflow:hidden}
#gameCanvas{width:100%;height:100%;image-rendering:pixelated;image-rendering:crisp-edges}
.hud{position:absolute;inset:0;display:flex;flex-direction:column;justify-content:space-between;pointer-events:none}
.topbar{display:flex;justify-content:space-between;gap:.75rem;padding:.75rem}
.panel{pointer-events:auto}
.panel .card{padding:.6rem .75rem}
#mobileControls{position:absolute;left:0;right:0;bottom:8px;display:grid;grid-template-columns:repeat(5,1fr);gap:.5rem;padding:0 .75rem}
#mobileControls .btn{height:56px}
@media(min-width:768px){
  #mobileControls{display:none}
}

/* ===== Below-the-fold content ===== */
#content{padding:32px 0}
h1,h2,h3{line-height:1.2;margin:.5em 0}
h1{font-size:clamp(1.8rem,3.5vw,2.4rem)}
h2{font-size:clamp(1.3rem,2.4vw,1.6rem)}
h3{font-size:clamp(1.05rem,1.8vw,1.25rem)}
.lead{color:var(--muted)}
.article{max-width:760px}
.faq dt{font-weight:700;margin-top:10px}
.faq dd{margin:0 0 10px 0;color:var(--muted)}
/* Smooth glow for important UI */
.glow{box-shadow:0 0 0 1px rgba(0,229,255,.25), 0 0 24px rgba(0,229,255,.18) inset, 0 0 24px rgba(0,229,255,.18)}
/* Focus outline for a11y */
:focus-visible{outline:2px solid var(--accent);outline-offset:2px;border-radius:10px}
</style>
</head>
<body>
<main id="view">
  <canvas id="gameCanvas" width="360" height="640" aria-label="Tetris Game Canvas"></canvas>

  <!-- Overlay HUD -->
  <div class="hud">
    <div class="topbar">
      <div class="panel glass rounded-2xl shadow-lg">
        <div class="card">
          <div class="text-xs uppercase opacity-70">Score</div>
          <div id="score" class="text-2xl font-bold neon">0</div>
        </div>
      </div>
      <div class="panel glass rounded-2xl shadow-lg">
        <div class="card">
          <div class="text-xs uppercase opacity-70">Level</div>
          <div id="level" class="text-2xl font-bold" style="color:#a5f3fc">1</div>
        </div>
      </div>
      <div class="panel glass rounded-2xl shadow-lg">
        <div class="card">
          <div class="text-xs uppercase opacity-70">Lines</div>
          <div id="lines" class="text-2xl font-bold" style="color:#86efac">0</div>
        </div>
      </div>
      <div class="panel glass rounded-2xl shadow-lg">
        <div class="card">
          <div class="text-xs uppercase opacity-70">Next</div>
          <canvas id="nextCanvas" width="80" height="80" style="image-rendering:pixelated"></canvas>
        </div>
      </div>
      <div class="panel glass rounded-2xl shadow-lg">
        <div class="card flex items-center gap-3">
          <button id="pauseBtn" class="btn glow" title="Pause (P)">⏸</button>
          <button id="resetBtn" class="btn" title="Reset">↻</button>
        </div>
      </div>
    </div>

    <!-- Mobile controls -->
    <div id="mobileControls" class="panel">
      <button class="btn glow" id="leftBtn" aria-label="Move Left">◀</button>
      <button class="btn" id="downBtn" aria-label="Soft Drop">▼</button>
      <button class="btn glow" id="rightBtn" aria-label="Move Right">▶</button>
      <button class="btn" id="rotateBtn" aria-label="Rotate">⟳</button>
      <button class="btn" id="hardBtn" aria-label="Hard Drop">⤓</button>
    </div>
  </div>
</main>

<!-- Below-the-fold SEO content -->
<section id="content">
  <div class="container">
    <header class="p-2">
      <span class="badge text-xs">PWA • Offline • 60 FPS</span>
      <h1 class="neon">Tetris Pixel Art – Classic Tetris You Can Play Anywhere</h1>
      <p class="lead">This responsive, mobile-first Tetris game features a 10×20 grid, seven classic tetrominoes, neon pixel art, and offline PWA support with LocalStorage high scores.</p>
    </header>
    <div class="grid gap-3 article">
      <article>
        <h2>What Makes This Tetris Special</h2>
        <p>
          This Tetris Pixel Art experience is crafted for speed, clarity, and accessibility. The game uses a crisp HTML5 Canvas renderer to deliver smooth 60 FPS gameplay and responsive controls. Desktop players use the arrow keys to move, the up arrow or spacebar to rotate, and the down arrow for soft drops. On mobile, large touch targets and swipe gestures keep every move precise. Level progression increases speed over time, while a classic score system rewards single, double, triple, and Tetris line clears with smart multipliers.
        </p>
        <h3>Optimized for Performance & SEO</h3>
        <p>
          The site is built as a Progressive Web App with a lightweight service worker for offline play, lightning-fast loading, and Core Web Vitals targets such as LCP under 2.5 seconds, INP under 200 milliseconds, and a CLS below 0.1. A dark theme with neon accents and glassmorphism panels provides a modern pixel art aesthetic. Structured data, Open Graph tags, canonical links, and an FAQ section help this Tetris page rank cleanly while keeping content accessible and relevant to players and search engines alike.
        </p>
      </article>

      <hr />

      <section aria-labelledby="faq">
        <h2 id="faq">Tetris Pixel Art – FAQ</h2>
        <dl class="faq">
          <dt>Does this Tetris work offline?</dt>
          <dd>Yes. Install it as a PWA and it works offline via a service worker.</dd>

          <dt>How do I rotate pieces?</dt>
          <dd>Press <strong>Up</strong> or <strong>Space</strong> on desktop, or tap the rotate button on mobile.</dd>

          <dt>Is there a high score?</dt>
          <dd>Yes. The game stores your best score using LocalStorage on your device.</dd>

          <dt>What devices are supported?</dt>
          <dd>Phones, tablets, and desktops. The layout is mobile-first and responsive.</dd>
        </dl>
      </section>
    </div>
  </div>
</section>

<!-- JSON-LD: VideoGame + FAQPage -->
<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@type":"VideoGame",
  "name":"Tetris Pixel Art",
  "url":"https://example.com/",
  "operatingSystem":"Web",
  "applicationCategory":"Game",
  "genre":"Puzzle",
  "playMode":"SinglePlayer",
  "description":"Play classic Tetris in a neon pixel art style. PWA, offline, mobile-first, high scores, next piece preview, and responsive controls.",
  "image":"https://example.com/icon-512.png",
  "inLanguage":"en",
  "publisher":{"@type":"Organization","name":"Your Studio"},
  "aggregateRating":{"@type":"AggregateRating","ratingValue":"4.8","ratingCount":"127"}
}
</script>
<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@type":"FAQPage",
  "mainEntity":[
    {"@type":"Question","name":"Does this Tetris work offline?","acceptedAnswer":{"@type":"Answer","text":"Yes. Install it as a PWA and it works offline via a service worker."}},
    {"@type":"Question","name":"How do I rotate pieces?","acceptedAnswer":{"@type":"Answer","text":"Press Up or Space on desktop, or tap the rotate button on mobile."}},
    {"@type":"Question","name":"Is there a high score?","acceptedAnswer":{"@type":"Answer","text":"Yes. The game stores your best score using LocalStorage on your device."}},
    {"@type":"Question","name":"What devices are supported?","acceptedAnswer":{"@type":"Answer","text":"Phones, tablets, and desktops. The layout is mobile-first and responsive."}}
  ]
}
</script>

<script>
/* ===================== TETRIS PIXEL ART – VANILLA JS ===================== */
/* Performance targets: rAF loop, tight draw, no external deps, 60 FPS */

/* ---- Constants ---- */
const COLS = 10, ROWS = 20, BLOCK = 24; // logical block size; canvas scales to viewport
const COLORS = {
  I: "#00e5ff",
  O: "#fde047",
  T: "#a855f7",
  S: "#22c55e",
  Z: "#ef4444",
  J: "#60a5fa",
  L: "#f59e0b",
  G: "#101522" // grid
};

const SHAPES = {
  I: [[0,1,0,0],
      [0,1,0,0],
      [0,1,0,0],
      [0,1,0,0]],
  O: [[1,1],
      [1,1]],
  T: [[0,1,0],
      [1,1,1],
      [0,0,0]],
  S: [[0,1,1],
      [1,1,0],
      [0,0,0]],
  Z: [[1,1,0],
      [0,1,1],
      [0,0,0]],
  J: [[1,0,0],
      [1,1,1],
      [0,0,0]],
  L: [[0,0,1],
      [1,1,1],
      [0,0,0]]
};

const PIECES = Object.keys(SHAPES);

/* ---- State ---- */
let canvas = document.getElementById("gameCanvas");
let ctx = canvas.getContext("2d");
let nextCanvas = document.getElementById("nextCanvas");
let nctx = nextCanvas.getContext("2d");
let grid = createMatrix(COLS, ROWS);
let piece = null, nextPiece = randomPiece();
let score = 0, lines = 0, level = 1, best = +localStorage.getItem("tetris_best") || 0;
let dropInterval = 800, lastTime = 0, acc = 0;
let paused = false, gameOver = false;

/* ---- Utility ---- */
function createMatrix(w,h){ return Array.from({length:h},()=>Array(w).fill(0)); }
function clone(m){ return m.map(r=>r.slice()); }
function rotate(shape){
  const N = shape.length, res = createMatrix(N,N);
  for(let y=0;y<N;y++) for(let x=0;x<N;x++) res[x][N-1-y]=shape[y][x];
  // trim empty rows/cols
  return trim(res);
}
function trim(mat){
  // remove full empty rows/cols
  let top=0,bottom=mat.length-1,left=0,right=mat[0].length-1;
  const emptyRow = r => r.every(v=>!v);
  const emptyCol = c => mat.every(r=>!r[c]);
  while(top<=bottom && emptyRow(mat[top])) top++;
  while(bottom>=top && emptyRow(mat[bottom])) bottom--;
  while(left<=right && emptyCol(left)) left++;
  while(right>=left && emptyCol(right)) right--;
  const out=[]; for(let y=top;y<=bottom;y++){ out.push(mat[y].slice(left,right+1)); }
  return out.length?out:[[0]];
}
function randomPiece(){
  const t = PIECES[(Math.random()*PIECES.length)|0];
  return { type:t, shape:clone(SHAPES[t]), x:(COLS>>1)-1, y:0 };
}
function collide(g,p){
  for(let y=0;y<p.shape.length;y++){
    for(let x=0;x<p.shape[y].length;x++){
      if(p.shape[y][x] && (g[p.y+y]?.[p.x+x]??1)) return true;
    }
  }
  return false;
}
function merge(g,p){
  for(let y=0;y<p.shape.length;y++)
    for(let x=0;x<p.shape[y].length;x++)
      if(p.shape[y][x]) g[p.y+y][p.x+x]=p.type;
}
function clearLines(){
  let cleared = 0;
  for(let y=ROWS-1;y>=0;y--){
    if(grid[y].every(v=>v)) {
      grid.splice(y,1);
      grid.unshift(Array(COLS).fill(0));
      cleared++; y++;
    }
  }
  if(cleared){
    const mult = [0, 100, 300, 500, 800][cleared] || (cleared*300);
    score += mult * level;
    lines += cleared;
    level = 1 + Math.floor(lines / 10);
    dropInterval = Math.max(120, 800 - (level-1)*60);
    updateHUD();
  }
}
function updateHUD(){
  document.getElementById("score").textContent = score.toLocaleString();
  document.getElementById("level").textContent = level;
  document.getElementById("lines").textContent = lines;
}
function resetGame(){
  grid = createMatrix(COLS,ROWS);
  piece = null;
  nextPiece = randomPiece();
  score = 0; lines = 0; level = 1; dropInterval = 800;
  gameOver = false; paused = false;
  spawn();
  updateHUD();
}

/* ---- Rendering ---- */
function resizeCanvas(){
  const vw = window.innerWidth, vh = window.innerHeight;
  // keep aspect (10:20 ~ 1:2). We fill viewport and letterbox inside canvas drawing.
  canvas.width = Math.floor(vw * devicePixelRatio);
  canvas.height = Math.floor(vh * devicePixelRatio);
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
window.addEventListener('resize', resizeCanvas);

/* Pixel art block */
function drawBlock(px,py,color,unit){
  ctx.fillStyle = color;
  const s = unit;
  ctx.fillRect(px,py,s,s);
  // Bevel for pixel art
  ctx.fillStyle = "rgba(255,255,255,.08)";
  ctx.fillRect(px,py,s,Math.max(1, s*0.12));
  ctx.fillStyle = "rgba(0,0,0,.25)";
  ctx.fillRect(px,py+s- Math.max(1, s*0.12),s,Math.max(1, s*0.12));
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const W = canvas.clientWidth, H = canvas.clientHeight;
  const unit = Math.floor(Math.min(W/COLS, H/ROWS));
  const offsetX = Math.floor((W - unit*COLS)/2);
  const offsetY = Math.floor((H - unit*ROWS)/2);

  // grid background
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.fillRect(offsetX-6, offsetY-6, unit*COLS+12, unit*ROWS+12);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      ctx.fillStyle = (x+y)%2 ? "#0d1320" : "#0c111b";
      ctx.fillRect(offsetX+x*unit, offsetY+y*unit, unit, unit);
      if(grid[y][x]){
        drawBlock(offsetX+x*unit, offsetY+y*unit, COLORS[grid[y][x]], unit);
      }
    }
  }
  // active piece
  if(piece){
    for(let y=0;y<piece.shape.length;y++)
      for(let x=0;x<piece.shape[y].length;x++)
        if(piece.shape[y][x]){
          drawBlock(offsetX+(piece.x+x)*unit, offsetY+(piece.y+y)*unit, COLORS[piece.type], unit);
        }
  }
  // game over overlay
  if(gameOver){
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle="#fff";
    ctx.font="bold 28px system-ui,Segoe UI,Roboto";
    ctx.textAlign="center";
    ctx.fillText("Game Over", W/2, H/2 - 10);
    ctx.font="16px system-ui,Segoe UI,Roboto";
    ctx.fillText("Tap ↻ Reset to play again", W/2, H/2 + 18);
  }
}

/* Next piece preview */
function drawNext(){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  const u = 16, offx = 12, offy = 12;
  const s = nextPiece.shape;
  for(let y=0;y<s.length;y++)
    for(let x=0;x<s[y].length;x++)
      if(s[y][x]){
        nctx.fillStyle = "#0b0f17";
        nctx.fillRect(offx+x*u-2,offy+y*u-2,u+4,u+4);
        nctx.fillStyle = COLORS[nextPiece.type];
        nctx.fillRect(offx+x*u,offy+y*u,u,u);
      }
}

/* ---- Game Flow ---- */
function spawn(){
  piece = nextPiece;
  piece.x = (COLS>>1) - Math.ceil(piece.shape[0].length/2);
  piece.y = 0;
  nextPiece = randomPiece();
  drawNext();
  if(collide(grid,piece)){
    gameOver = true;
    best = Math.max(best, score);
    localStorage.setItem("tetris_best", best);
  }
}

function hardDrop(){
  if(!piece) return;
  while(!collide(grid, {...piece, y:piece.y+1})) piece.y++;
  lockPiece();
}

function lockPiece(){
  merge(grid,piece);
  clearLines();
  spawn();
}

function move(dx){
  if(!piece) return;
  const np = {...piece, x:piece.x+dx};
  if(!collide(grid,np)) piece.x = np.x;
}

function softDrop(){
  if(!piece) return;
  const np = {...piece, y:piece.y+1};
  if(!collide(grid,np)){ piece.y++; score += 1; updateHUD(); }
  else { lockPiece(); }
}

function rotatePiece(){
  if(!piece) return;
  const rs = rotate(piece.shape);
  const np = {...piece, shape:rs};
  // Wall kicks (simple)
  const kicks = [0,-1,1,-2,2];
  for(const k of kicks){
    const test = {...np, x:piece.x + k};
    if(!collide(grid,test)){ piece.shape = rs; piece.x = test.x; return; }
  }
}

/* ---- Input ---- */
document.addEventListener('keydown', (e)=>{
  if(gameOver) return;
  if(e.code==="ArrowLeft"){ move(-1); }
  else if(e.code==="ArrowRight"){ move(1); }
  else if(e.code==="ArrowDown"){ softDrop(); }
  else if(e.code==="ArrowUp" || e.code==="Space"){ rotatePiece(); }
  else if(e.code==="KeyP"){ togglePause(); }
});

function togglePause(){
  paused = !paused;
  document.getElementById("pauseBtn").textContent = paused ? "▶" : "⏸";
}

document.getElementById("pauseBtn").addEventListener("click", togglePause);
document.getElementById("resetBtn").addEventListener("click", resetGame);

document.getElementById("leftBtn").addEventListener("click", ()=>move(-1));
document.getElementById("rightBtn").addEventListener("click", ()=>move(1));
document.getElementById("downBtn").addEventListener("click", softDrop);
document.getElementById("rotateBtn").addEventListener("click", rotatePiece);
document.getElementById("hardBtn").addEventListener("click", hardDrop);

/* Swipe gestures */
let touchStartX=0,touchStartY=0, touching=false;
canvas.addEventListener('touchstart', (e)=>{
  const t=e.changedTouches[0]; touchStartX=t.clientX; touchStartY=t.clientY; touching=true;
},{passive:true});
canvas.addEventListener('touchend', (e)=>{
  if(!touching) return; touching=false;
  const t=e.changedTouches[0];
  const dx=t.clientX - touchStartX, dy=t.clientY - touchStartY;
  const ax=Math.abs(dx), ay=Math.abs(dy);
  if(Math.max(ax,ay)<24){ rotatePiece(); return; } // tap = rotate
  if(ax>ay){ dx>0 ? move(1) : move(-1); }
  else{ dy>0 ? softDrop() : hardDrop(); }
},{passive:true});

/* ---- Loop ---- */
function update(t){
  const dt = t - lastTime; lastTime = t;
  if(!paused && !gameOver){
    acc += dt;
    while(acc > dropInterval){ acc -= dropInterval; softDrop(); break; }
  }
  draw();
  requestAnimationFrame(update);
}

/* ---- PWA registration ---- */
if('serviceWorker' in navigator){
  window.addEventListener('load', ()=> navigator.serviceWorker.register('./service-worker.js'));
}

/* ---- Init ---- */
function init(){
  resizeCanvas();
  resetGame();
  requestAnimationFrame(update);
  updateHUD();
  drawNext();

  // expose best score
  const b = +localStorage.getItem("tetris_best") || 0;
  if(!document.getElementById('bestBadge')){
    const span = document.createElement('span');
    span.id='bestBadge'; span.className='badge text-xs px-3 py-2';
    span.textContent = 'Best: ' + b.toLocaleString();
    document.querySelector('.topbar').prepend(span);
  }
}
init();
</script>
</body>
</html>
